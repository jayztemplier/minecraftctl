#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'minecraft'
require 'message_collector'

class MessageCollectorProcessed < MessageCollector
  def initialize(&operations)
    super(&operations)
    @processors = []
  end

  def process(&block)
    @processors << block
    self
  end

  def collect(msg)
    @processors.each do |processor|
      msg = processor.call(msg)
    end
    @collector.call(msg)
  end

end

class TextCollector < MessageCollectorProcessed
  def initialize(&operations)
    super
    process do |msg|
      msg.to_s + "\n"
    end
  end
end

class Daemon
	def self.daemonize(pid_file, log_file = nil)
		exit if fork
		Process.setsid # become session leader
		exit if fork # and exits
		# now in child
	
		# try to lock before we kill stdin/out
		lock(pid_file)

		if log_file
			log = File.open(log_file, 'a')
		else
			log = '/dev/null'
		end

		# disconnect
		STDIN.reopen '/dev/null'
		STDOUT.reopen log
		STDERR.reopen log
	end

	def self.lock(pid_file)
		pf = File.open(pid_file, File::RDWR | File::CREAT)
		fail "Server already running with pid: #{pf.read}" unless pf.flock(File::LOCK_EX|File::LOCK_NB)
		pf.truncate(0)
		pf.write(Process.pid.to_s)
		pf.flush
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
    argument_required
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
    argument_required
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
    argument_required
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
    argument_required
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
    argument_required
	end

	run do
		pid_file = Pathname.new(params['minecraft-dir'].value) + params['pid-file'].value
		log_file = Pathname.new(params['minecraft-dir'].value) + params['log-file'].value

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		require 'sinatra/base'
		require 'haml'

		Dir.chdir(params['minecraft-dir'].value)

		minecraft = Minecraft.new(params['command'].value)

		minecraft.start

		s = Sinatra.new
		s.set :port, params['port'].value
    s.set :environment, 'production'

		s.post '/save-all' do
			TextCollector.for(minecraft) do
				save_all
			end
		end

		s.post '/start' do
			TextCollector.for(minecraft) do
				start
			end
		end

		s.post '/stop' do
			TextCollector.for(minecraft) do
				stop
			end
		end

		s.post '/shutdown' do
			TextCollector.for(minecraft) do
				stop

				pid = Process.pid
				Thread.new{ sleep 1; Process.kill(15, pid)}
			end
		end

		s.post %r{/(.+)} do |cmd|
			args = request.body.read.split("\n")
			TextCollector.for(minecraft) do
        send(cmd.tr('-', '_').to_sym, *args)
			end
		end

		s.get '/help' do
			start = false
			TextCollector.for(minecraft) do
        help
				log "status                    show server status"
				log "log                       show recent server messages"
				log "inspect                   inspect recent server messages"
			end.process do |msg|
        msg = msg.to_s

        if msg =~ /Console commands:/
          start = true 
          next
        end

        next unless start
        msg.sub(/help  or  \?/, 'serverhelp ').sub(/^( |\t)*/, '')
      end
		end

		s.get '/list' do
			TextCollector.for(minecraft) do
				list
			end
		end

    s.get '/status' do
      if minecraft.running?
        @pid = minecraft.server_pid
        haml :status_running
      else
        haml :status_stopped
      end
    end

		s.get '/inspect' do
			@msg = minecraft.history
			haml :messages_inspect
		end

		s.get '/log' do
			@msg = minecraft.history
			haml :messages
		end

    s.template :status_running do
      '= "Minecraft server is running with pid: #{@pid}"'
    end

    s.template :status_stopped do
      '= "Minecraft server is stopped"'
    end

		s.template :messages do
			'= @msg.join("\n")'
		end

		s.template :messages_inspect do
			'= @msg.map{|m| m.inspect}.join("\n")'
		end

    s.not_found do
      "Request '#{env['REQUEST_PATH']}' not supported, please see '/serverhelp' for details\n"
    end

    s.error do
      "Error in minecraftctlserver while processing request '#{env['REQUEST_PATH']}': #{env['sinatra.error']}\n" 
    end

		s.run!
	end
end
