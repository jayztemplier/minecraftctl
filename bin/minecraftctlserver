#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'
require 'daemon'
require 'sinatra/base'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'minecraft'
require 'message_collector'

class MessageCollectorProcessed < MessageCollector
	def initialize(&operations)
		super(&operations)
		@processors = []
	end

	def process(&block)
		@processors << block
		self
	end

	def collect(msg)
		@processors.each do |processor|
			msg = processor.call(msg)
		end
		@collector.call(msg) if msg
	end
end

class TextCollector < MessageCollectorProcessed
	def initialize(&operations)
		super
		process do |msg|
			msg.to_s + "\n"
		end
	end
end

class APIBuilder
	def initialize(sinatra, description, path = '', &block)
		@sinatra = sinatra
		@description = description

		@dsl = DSL.new(sinatra, path, &block).data
		@path = path
		root = self

		@sinatra.get(path.empty? ? '/' : path) do
			root.help.join("\n") + "\n"
		end

		@dsl.gets.each do |op|
			@sinatra.get(path + '/' + op.name, &op.block)
		end

		@dsl.posts.each do |op|
			@sinatra.post(path + '/' + op.name, &op.block)
		end
	end

	def help
		out = []
		out << "#{@description}:"
		@dsl.gets.each do |op|
			out << "  GET #{@path}/#{op.name} - #{op.description}"
		end
		@dsl.posts.each do |op|
			out << "  POST #{@path}/#{op.name} - #{op.description}"
		end
		@dsl.paths.each do |path|
			out += path.help
		end
		out
	end

	class DSL
		OP = Struct.new(:name, :description, :block)
		def initialize(sinatra, path, &block)
			@sinatra = sinatra
			@path = path

			@gets = []
			@posts = []
			@paths = []

			instance_eval(&block)
		end

		def data
			Struct.new(:gets, :posts, :paths).new(@gets, @posts, @paths)
		end

		def get(name, description, &block)
			@gets << OP.new(name, description, block)
		end

		def post(name, description, &block)
			@posts << OP.new(name, description, block)
		end

		def path(name, description, &block)
			@paths << APIBuilder.new(@sinatra, description, @path + '/' + name, &block)
		end
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
		argument_required
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
		argument_required
	end

	option 'bind', 'b' do
		description 'IP address of interface to listen for connections on; use 0.0.0.0 to bind to all interfaces'
		default '127.0.0.1'
		argument_required
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
		argument_required
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
		argument_required
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
		argument_required
	end

	run do
		pid_file = Pathname.new(params['pid-file'].value)
		log_file = Pathname.new(params['log-file'].value)

		Dir.chdir(params['minecraft-dir'].value)

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		minecraft = Minecraft.new(params['command'].value)
		minecraft.start

		s = Sinatra.new
		s.set :port, params['port'].value
		s.set :bind, params['bind'].value
		s.set :environment, 'production'
		s.set :server, ['mongrel']
		s.set :lock, true

		APIBuilder.new(s, 'Minecraft control server') do
			post 'shutdown', 'shutdown the server and ctlserver' do
				TextCollector.for(minecraft) do
					minecraft.stop if minecraft.running?
					log "Shutting down minecraftctlserver"

					pid = Process.pid
					Thread.new{Process.kill(15, pid)}
				end
			end

			get 'inspect', 'internal representation of logged data' do
				minecraft.history.map{|m| m.inspect}.join("\n")
			end

			get 'log', 'show log output generated by minecraft server' do
				minecraft.history.join("\n")
			end

			get 'dir', 'minecraft server installation directory' do
				Dir.pwd + "\n"
			end

			get 'pid', 'minecraftctlserver PID' do
				Process.pid.to_s + "\n"
			end

			path 'server', 'Control minecraft server runtime status'  do
				post 'start', 'starts minecraft server' do
					TextCollector.for(minecraft) do
						start
					end
				end

				post 'stop', 'stops minecraft server' do
					TextCollector.for(minecraft) do
						stop
					end
				end

				get 'status', 'server status' do
					if minecraft.running?
						"running\n"
					else
						"stopped\n"
					end
				end

				get 'pid', 'minecraft server PID' do
					minecraft.server_pid.to_s + "\n"
				end

				post 'console', 'execute console command' do
					cmd, *args = request.body.read.split("\n")
					TextCollector.for(minecraft) do
						send(cmd.tr('-', '_').to_sym, *args)
					end
				end
			end
		end

		s.not_found do
			"Request '#{env['REQUEST_PATH']}' not supported, please see '/serverhelp' for details\n"
		end

		s.error do
			"Error in minecraftctlserver while processing request '#{env['REQUEST_PATH']}': #{env['sinatra.error']}\n" 
		end

		s.run!

		# make sure we stop the server on exit
		minecraft.stop if minecraft.running?
	end
end

