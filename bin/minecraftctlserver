#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'minecraft'
require 'message_collector'

class MessageCollectorProcessed < MessageCollector
  def initialize(&operations)
    super(&operations)
    @processors = []
  end

  def process(&block)
    @processors << block
    self
  end

  def collect(msg)
    @processors.each do |processor|
      msg = processor.call(msg)
    end
    @collector.call(msg)
  end

end

class TextCollector < MessageCollectorProcessed
  def initialize(&operations)
    super
    process do |msg|
      msg.to_s + "\n"
    end
  end
end

class Daemon
	def self.daemonize(pid_file, log_file = nil)
		exit if fork
		Process.setsid # become session leader
		exit if fork # and exits
		# now in child
	
		# try to lock before we kill stdin/out
		lock(pid_file)

		if log_file
			log = File.open(log_file, 'a')
		else
			log = '/dev/null'
		end

		# disconnect
		STDIN.reopen '/dev/null'
		STDOUT.reopen log
		STDERR.reopen log
	end

	def self.lock(pid_file)
		pf = File.open(pid_file, File::RDWR | File::CREAT)
		fail "Server already running with pid: #{pf.read}" unless pf.flock(File::LOCK_EX|File::LOCK_NB)
		pf.truncate(0)
		pf.write(Process.pid.to_s)
		pf.flush
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
	end

	run do
		pid_file = Pathname.new(params['minecraft-dir'].value) + params['pid-file'].value
		log_file = Pathname.new(params['minecraft-dir'].value) + params['log-file'].value

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		require 'sinatra/base'
		require 'haml'

		Dir.chdir(params['minecraft-dir'].value)

		minecraft = Minecraft.new(params['command'].value)

		minecraft.start

		s = Sinatra.new
		s.set :port, params['port'].value

		s.post '/save-all' do
			TextCollector.for(minecraft) do
				save_all
			end
		end

		s.post '/start' do
			TextCollector.for(minecraft) do
				start
			end
		end

		s.post '/stop' do
			TextCollector.for(minecraft) do
				stop
			end
		end

		s.post '/shutdown' do
			TextCollector.for(minecraft) do
				stop

				pid = Process.pid
				Thread.new{ sleep 1; Process.kill(15, pid)}
			end
		end

		s.post %r{/(.+)} do |cmd|
			args = request.body.read.split("\n")
			TextCollector.for(minecraft) do
        send(cmd.tr('-', '_').to_sym, *args)
			end
		end

		s.get '/help' do
			start = false
			TextCollector.for(minecraft) do
        help
				log "log                       show recent server messages"
				log "inspect                   inspect recent server messages"
			end.process do |msg|
        msg = msg.to_s

        if msg =~ /Console commands:/
          start = true 
          next
        end

        next unless start
        msg.sub(/help  or  \?/, 'serverhelp ').sub(/^( |\t)*/, '')
      end
		end

		s.get '/list' do
			TextCollector.for(minecraft) do
				list
			end
		end

		s.get '/inspect' do
			@msg = minecraft.history
			haml :messages_inspect
		end

		s.get '/log' do
			@msg = minecraft.history
			haml :messages
		end

		s.template :messages do
			'= @msg.join("\n")'
		end

		s.template :messages_inspect do
			'= @msg.map{|m| m.inspect}.join("\n")'
		end

		s.run!
	end
end
