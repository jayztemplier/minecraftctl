#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'minecraft'

class Daemon
	def self.daemonize(pid_file, log_file = nil)
		exit if fork
		Process.setsid # become session leader
		exit if fork # and exits
		# now in child
	
		# try to lock before we kill stdin/out
		lock(pid_file)

		if log_file
			log = File.open(log_file, 'a')
		else
			log = '/dev/null'
		end

		# disconnect
		STDIN.reopen '/dev/null'
		STDOUT.reopen log
		STDERR.reopen log
	end

	def self.lock(pid_file)
		pf = File.open(pid_file, 'r+')
		fail "Server already running with pid: #{pf.read}" unless pf.flock(File::LOCK_EX|File::LOCK_NB)
		pf.truncate(0)
		pf.write(Process.pid.to_s)
		pf.flush
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
	end

	run do
		pid_file = Pathname.new(params['minecraft-dir'].value) + params['pid-file'].value
		log_file = Pathname.new(params['minecraft-dir'].value) + params['log-file'].value

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		require 'sinatra/base'
		require 'haml'

		Dir.chdir(params['minecraft-dir'].value)

		minecraft = Minecraft.new(params['command'].value)

		minecraft.start

		s = Sinatra.new
		s.set :port, params['port'].value

		s.post '/save-all' do
			minecraft.transaction do
				save_all
			end
		end

		s.post '/start' do
			minecraft.transaction do
				start
			end
		end

		s.post '/stop' do
			minecraft.transaction do
				stop
			end
		end

		s.post '/shutdown' do
			minecraft.transaction do
				stop

				pid = Process.pid
				Thread.new{ sleep 1; Process.kill(15, pid)}
			end
		end

		s.post %r{/(.+)} do |cmd|
			args = request.body.read.split("\n")
			minecraft.transaction do
				command(cmd + " " + args.join(' '))
			end
		end

		s.get '/help' do
			start = false
			minecraft.transaction do
				command('help')
				internal_msg "log                       show recent server messages"
				internal_msg "inspect                   inspect recent server messages"
			end.process do |msg|
				msg = msg.to_s
				if msg =~ /Console commands:/
					start = true 
					next
				end
				next unless start

				msg.sub!(/help  or  \?/, 'serverhelp ')
				msg.sub!(/^( |\t)*/, '')
				msg
			end
		end

		s.get '/list' do
			minecraft.transaction do
				minecraft.list
			end
		end

		s.get '/inspect' do
			@msg = minecraft.history
			haml :messages_inspect
		end

		s.get '/log' do
			@msg = minecraft.history
			haml :messages
		end

		s.template :messages do
			'= @msg.join("\n")'
		end

		s.template :messages_inspect do
			'= @msg.map{|m| m.inspect}.join("\n")'
		end

		s.run!
	end
end
