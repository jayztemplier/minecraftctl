#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'

class Message
	def initialize(msg)
		@msg = msg
	end

	attr_reader :msg

	def to_s
		@msg.dup
	end

	class Internal < Message
		def initialize(msg)
			super(msg)
		end
	end

	class Out < Message
		def initialize(msg)
			super(msg)
		end
	end

	class Err < Message
		def initialize(line)
			x, @time, @level, msg = *line.match(/^([^ ]* [^ ]*) \[([^\]]*)\] (.*)/)
			super(msg)
		end

		attr_reader :time, :level
	end
end

class Minecraft
	class Output
		def initialize(queue, history)
			@queue = queue
			@history = history
			@brake_cond = nil
			flush
		end

		def wait(discard = false, &block)
			@brake_cond = block
			@discard = discard
		end

		def flush
			until @queue.empty? 
				msg = @queue.pop(true)
				@history << msg
				yield msg if block_given?
			end
		end

		def put(msg)
			@history << msg
		end

		def each
			loop do
				msg = @queue.pop
				@history << msg
				if @brake_cond and @brake_cond.call(msg)
					yield msg unless @discard
					return
				end
				yield msg
			end
		end
	end

	def initialize(cmd)
		@cmd = cmd
		@in_queue = Queue.new
		@out_queue = Queue.new

		@running = false

		@history = []

		@output = Output.new(@out_queue, @history)

		@collector = nil
		@processor = nil
	end

	def transaction(&block)
		@transaction = block
		self
	end

	def process(&block)
		@processor = block	
		self
	end

	# start processing
	def each(&block)
		@collector = block
		@output.flush
		instance_eval &@transaction
		@output.flush do |msg|
			collect(msg)
		end
	end

	def running?
		@running
	end

	def start
		if @running
			internal_msg "Server already running"
		else
			time_operation("Server start") do
				@stdin, stdout, stderr = Open3.popen3(@cmd) 
				@running = true

				@out_reader = Thread.new do
					stdout.each do |line|
						m = Message::Out.new(line)
						puts m
						@out_queue << m
					end
				end

				@err_reader = Thread.new do
					stderr.each do |line|
						m = Message::Err.new(line)
						puts m
						@out_queue << m
					end
				end

				wait_msg do |m|
					m.msg =~ /Done \(([^n]*)ns\)!/
				end
			end
		end
	end

	def stop
		unless @running
			internal_msg "Server already stopped"
		else
			command('stop') do
				@running = false
				time_operation("Server stop") do
					@out_reader.join
					@err_reader.join
					internal_msg "Server stopped"
				end

				wait_msg{|m| m.msg == "Server stopped"}
			end
		end
	end

	def save_all
		command('save-all') do
			time_operation("Save") do
				wait_msg{|m| m.msg =~ /Save complete/}
			end
		end
	end

	def list
		command('list') do
			wait_msg{|m| m.msg =~ /Connected players:/}
		end
	end

	def command(cmd)
		raise RuntimeError, "server not running" unless @running
		@stdin.write("#{cmd}\n")
		if block_given?
			yield 
		else
			active_wait
		end
	end

	attr_reader :history

	private

	def collect(msg)
		msg = @processor.call(msg) if @processor
		return unless msg
		@collector.call(msg.to_s + "\n") if @collector
	end

	def internal_msg(msg)
		@out_queue << Message::Internal.new(msg)
	end

	def time_operation(name)
		start = Time.now
		yield
		internal_msg "#{name} finished in #{(Time.now - start).to_f}"
	end

	def wait_msg(discard = false, &block)
		# set wait contition
		@output.wait(discard, &block)

		# pass messages to collector if one defined
		@output.each do |msg|
			collect(msg)
		end
	end

	def active_wait
		@stdin.write("list\n")
		wait_msg(true){|m| m.msg =~ /Connected players:/}
	end

end

class Daemon
	def self.daemonize(pid_file, log_file = nil)
		exit if fork
		Process.setsid # become session leader
		exit if fork # and exits
		# now in child
	
		# try to lock before we kill stdin/out
		lock(pid_file)

		if log_file
			log = File.open(log_file, 'a')
		else
			log = '/dev/null'
		end

		# disconnect
		STDIN.reopen '/dev/null'
		STDOUT.reopen log
		STDERR.reopen log
	end

	def self.lock(pid_file)
		pf = File.open(pid_file, 'r+')
		fail "Server already running with pid: #{pf.read}" unless pf.flock(File::LOCK_EX|File::LOCK_NB)
		pf.truncate(0)
		pf.write(Process.pid.to_s)
		pf.flush
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
	end

	run do
		pid_file = Pathname.new(params['minecraft-dir'].value) + params['pid-file'].value
		log_file = Pathname.new(params['minecraft-dir'].value) + params['log-file'].value

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		require 'sinatra/base'
		require 'haml'

		Dir.chdir(params['minecraft-dir'].value)

		minecraft = Minecraft.new(params['command'].value)

		minecraft.start

		s = Sinatra.new
		s.set :port, params['port'].value

		s.post '/save-all' do
			minecraft.transaction do
				save_all
			end
		end

		s.post '/start' do
			minecraft.transaction do
				start
			end
		end

		s.post '/stop' do
			minecraft.transaction do
				stop
			end
		end

		s.post '/shutdown' do
			minecraft.transaction do
				stop

				pid = Process.pid
				Thread.new{ sleep 1; Process.kill(15, pid)}
			end
		end

		s.post %r{/(.+)} do |cmd|
			args = request.body.read.split("\n")
			minecraft.transaction do
				command(cmd + " " + args.join(' '))
			end
		end

		s.get '/help' do
			start = false
			minecraft.transaction do
				command('help')
				internal_msg "log                       show recent server messages"
				internal_msg "inspect                   inspect recent server messages"
			end.process do |msg|
				msg = msg.to_s
				if msg =~ /Console commands:/
					start = true 
					next
				end
				next unless start

				msg.sub!(/help  or  \?/, 'serverhelp ')
				msg.sub!(/^( |\t)*/, '')
				msg
			end
		end

		s.get '/list' do
			minecraft.transaction do
				minecraft.list
			end
		end

		s.get '/inspect' do
			@msg = minecraft.history
			haml :messages_inspect
		end

		s.get '/log' do
			@msg = minecraft.history
			haml :messages
		end

		s.template :messages do
			'= @msg.join("\n")'
		end

		s.template :messages_inspect do
			'= @msg.map{|m| m.inspect}.join("\n")'
		end

		s.run!
	end
end
