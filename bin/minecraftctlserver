#!/usr/bin/ruby
require 'rubygems'
require 'main'
require 'open3'
require 'thread'
require 'pathname'
require 'daemon'
require 'sinatra/base'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'minecraft'
require 'message_collector'

class MessageCollectorProcessed < MessageCollector
	def initialize(&operations)
		super(&operations)
		@processors = []
	end

	def process(&block)
		@processors << block
		self
	end

	def collect(msg)
		@processors.each do |processor|
			msg = processor.call(msg)
		end
		@collector.call(msg) if msg
	end
end

class TextCollector < MessageCollectorProcessed
	def initialize(&operations)
		super
		process do |msg|
			msg.to_s + "\n"
		end
	end
end

class APIBuilder
	def initialize(sinatra, description, path = '', &block)
		@sinatra = sinatra
		@description = description

		@dsl = DSL.new(sinatra, path, &block).data
		@path = path
		root = self

		@sinatra.get(root_path) do
			root.help.join("\n") + "\n"
		end

		@dsl.gets.each do |op|
			@sinatra.get(path + '/' + op.name, &op.block)
		end

		post_map = {}

		@dsl.posts.each do |op|
			post_map[op.name] = op
		end

		@sinatra.post(root_path) do
			cmd, *args = request.body.read.split(' ')
			op = post_map[cmd] or return "unknown command: #{cmd}\n"
			op.block.call(args)
		end
	end

	def root_path
		@path.empty? ? '/' : @path
	end

	def help
		out = []
		out << "GET #{root_path} - #{@description}"

		@dsl.posts.each do |op|
			out << "POST #{root_path} #{op.name} - #{op.description}"
		end

		@dsl.gets.each do |op|
			out << "GET #{@path}/#{op.name} - #{op.description}"
		end

		@dsl.paths.each do |path|
			out += path.help
		end

		out
	end

	class DSL
		OP = Struct.new(:name, :description, :block)
		def initialize(sinatra, path, &block)
			@sinatra = sinatra
			@path = path

			@gets = []
			@posts = []
			@paths = []

			instance_eval(&block)
		end

		def data
			Struct.new(:gets, :posts, :paths).new(@gets, @posts, @paths)
		end

		def get(name, description, &block)
			@gets << OP.new(name, description, block)
		end

		def post(name, description, &block)
			@posts << OP.new(name, description, block)
		end

		def path(name, description, &block)
			@paths << APIBuilder.new(@sinatra, description, @path + '/' + name, &block)
		end
	end
end

Main do
	description 'lounches Minecraft server that can be controlled via HTTP'

	option 'command', 'c' do
		default 'java -Xms256M -Xmx512M -Djava.net.preferIPv4Stack=true -jar minecraft_server.jar nogui'
		description 'command to be used to span server'
		argument_required
	end

	option 'port', 'p' do
		default 25560
		description 'port on which the control HTTP server should be running'
		argument_required
	end

	option 'bind', 'b' do
		description 'IP address of interface to listen for connections on; use 0.0.0.0 to bind to all interfaces'
		default '127.0.0.1'
		argument_required
	end

	option 'foreground', 'f' do
		description 'don\'t daemonize'
	end

	option 'pid-file', 'P' do
		description 'pid file relative to minecraft-dir'
		default 'minecraftctlserver.pid'
		argument_required
	end

	option 'log-file', 'l' do
		description 'log file relative to minecraft-dir when in not in foreground'
		default 'minecraftctlserver.log'
		argument_required
	end

	argument 'minecraft-dir' do
		description 'directory path to mincraft server installation directory'
		argument_required
	end

	run do
		pid_file = Pathname.new(params['pid-file'].value)
		log_file = Pathname.new(params['log-file'].value)

		Dir.chdir(params['minecraft-dir'].value)

		if params['foreground'].given?
			Daemon.lock(pid_file)
		else
			Daemon.daemonize(pid_file, log_file)
		end

		minecraft = Minecraft.new(params['command'].value)
		minecraft.start

		sinatra = Sinatra.new
		sinatra.set :port, params['port'].value
		sinatra.set :bind, params['bind'].value
		sinatra.set :environment, 'production'
		sinatra.set :server, ['mongrel']
		sinatra.set :lock, true

		APIBuilder.new(sinatra, 'minecraft control server API') do
			#get 'inspect', 'internal representation of output data' do
				#minecraft.history.map{|m| m.inspect}.join("\n") + "\n"
			#end

			get 'dir', 'minecraft directory' do
				Dir.pwd + "\n"
			end

			get 'pid', 'minecraft control server PID' do
				Process.pid.to_s + "\n"
			end

			get 'pid_file', 'minecraft control server PID file' do
				pid_file.realpath.to_s + "\n"
			end

			get 'out', 'output generated by control and minecraft server' do
				minecraft.history.join("\n") + "\n"
			end

			post 'shutdown', 'shutdown minecraft and control server' do
				TextCollector.for(minecraft) do
					minecraft.stop if minecraft.running?
					log "Shutting down minecraftctlserver"

					pid = Process.pid
					Thread.new{Process.kill(15, pid)}
				end
			end

			path 'server', 'minecraft server API'  do
				get 'status', 'server status' do
					if minecraft.running?
						"running\n"
					else
						"stopped\n"
					end
				end

				get 'pid', 'minecraft server PID' do
					if minecraft.server_pid
						minecraft.server_pid.to_s + "\n"
					else
						"Server not running\n"
					end
				end

				post 'start', 'starts minecraft server' do
					TextCollector.for(minecraft) do
						start
					end
				end

				post 'stop', 'stops minecraft server' do
					TextCollector.for(minecraft) do
						stop
					end
				end

				post 'console', 'send console command' do |args|
					TextCollector.for(minecraft) do
						begin
							send(args.shift.tr('-', '_').to_sym, *args)
						rescue Minecraft::ServerNotRunningError
							log "Server not running"
						end
					end
				end
			end
		end

		sinatra.not_found do
			"Request '#{env['REQUEST_PATH']}' not supported, please see '/serverhelp' for details\n"
		end

		sinatra.error do
			"Error in minecraftctlserver while processing request '#{env['REQUEST_PATH']}': #{env['sinatra.error']}\n" 
		end

		sinatra.run!

		# make sure we stop the server on exit
		if minecraft.running?
			puts 'stopping minecraft'
			minecraft.stop 
		end
	end
end

